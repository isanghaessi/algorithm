{\rtf1\ansi
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;}
{\*\listtable}
{\*\listoverridetable}
\f0\fs24 \cf0 \pard\tx0\tx500\tx1000\tx1500\tx2000\tx2500\tx3000\tx3500\tx4000\tx4500\tx5000\tx5500\tx6000\ql\fi0\li0
0\uc0\u51012  \uc0\u50756 \uc0\u47308 \uc0\u54616 \uc0\u44592  \uc0\u50948 \uc0\u54644 \uc0\u49436 \uc0\u45716  1\uc0\u51012  \uc0\u45149 \uc0\u45236 \uc0\u50556  \uc0\u54620 \uc0\u45796 \uc0\u45716  \uc0\u44163 \uc0\u51012  [0, 1] \uc0\u49933 \uc0\u51004 \uc0\u47196  \uc0\u54364 \uc0\u54788 \uc0\u54616 \uc0\u45716  n\uc0\u44060 \uc0\u51032  \uc0\u53076 \uc0\u49828 \uc0\u44032  \uc0\u51080 \uc0\u45796 . \uc0\u53076 \uc0\u49828  \uc0\u44060 \uc0\u49688  n\uc0\u44284  \uc0\u51060  \uc0\u49933 \uc0\u46308 \uc0\u51012  \uc0\u51077 \uc0\u47141 \uc0\u51004 \uc0\u47196  \uc0\u48155 \uc0\u50520 \uc0\u51012  \uc0\u46412  \uc0\u47784 \uc0\u46304  \uc0\u53076 \uc0\u49828 \uc0\u44032  \uc0\u50756 \uc0\u47308  \uc0\u44032 \uc0\u45733 \uc0\u54620 \uc0\u51648  \uc0\u54032 \uc0\u48324 \uc0\u54616 \uc0\u46972 .\
\
Input: numCourses = 2, prerequisites = [[1,0]]\
Output: true\
\
1.dfs\
import collections\
\
class Solution:\
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\
        def dfs(c, p):\
            if finish[c] == True:\
                return True\
            if c in p[:-1]:\
                return False\
            for pr in pre[c]:\
                if dfs(pr, (p + [pr])[:]) == False:\
                    return False\
            return True\
        \
        pre = collections.defaultdict(list)\
        for c, p in prerequisites:\
            pre[c].append(p)\
        finish = [False if c in pre else True for c in range(numCourses)]\
        for i in range(len(finish)):\
            finish[i] = dfs(i, [i])\
            if finish[i] == False:\
                return False\
        return True\
\
import collections\
\
class Solution:\
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\
        def dfs(i):\
            if i in traced:\
                return False\
            if i in visited:\
                return True\
            traced.add(i)\
            for y in graph[i]:\
                if not dfs(y):\
                    return False\
            traced.remove(i)\
            visited.add(i)\
            return True\
        \
        graph = collections.defaultdict(list)\
        for x, y in prerequisites:\
            graph[x].append(y)\
        traced = set()\
        visited = set()\
        for x in list(graph):\
            if not dfs(x):\
                return False\
        return True}